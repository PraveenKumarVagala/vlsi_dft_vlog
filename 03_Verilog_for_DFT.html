<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verilog for DFT | DFT Blog</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1><a href="index.html">üîß DFT Blog</a></h1>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="02_Digital_Design_Fundamentals.html">‚Üê Prev</a>
                <a href="04_Introduction_to_DFT.html">Next ‚Üí</a>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="article-header">
            <span class="article-number">Part 3 of 11</span>
            <h1>Verilog for DFT Engineers</h1>
            <p class="subtitle">Write clean RTL that's easy to test</p>
            <p class="author">By <strong>Praveen Kumar Vagala</strong></p>
            <div class="view-counter">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                <span class="view-count">1,234</span> views
            </div>
        </div>

        <h2>Module Structure</h2>
        <p>Every Verilog design is built from modules.</p>

<pre><code>module module_name (
    // Port declarations
    input        clk,           // Single bit input
    input        rst_n,         // Active low reset (n = negative)
    input  [7:0] data_in,       // 8-bit input bus
    output       valid,         // Single bit output
    output [7:0] data_out,      // 8-bit output bus
    inout  [7:0] bidir          // Bidirectional (avoid if possible!)
);

    // Internal signals
    wire [7:0] internal_wire;
    reg  [7:0] internal_reg;
    
    // Your logic here
    
endmodule</code></pre>

        <div class="tip">Avoid <code>inout</code> ports - they create test complications.</div>

        <h2>Always Blocks - The Core of Verilog</h2>

        <h3>Combinational Logic - Use <code>=</code> (Blocking)</h3>
<pre><code>always @(*) begin              // Sensitive to ALL inputs
    case (sel)
        2'b00: out = a;
        2'b01: out = b;
        2'b10: out = c;
        default: out = d;      // Always have default!
    endcase
end</code></pre>

        <h3>Sequential Logic - Use <code>&lt;=</code> (Non-Blocking)</h3>
<pre><code>always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        q1 <= 1'b0;
        q2 <= 1'b0;
    end else begin
        q1 <= d;
        q2 <= q1;             // Creates shift register
    end
end</code></pre>

        <h2>Blocking vs Non-Blocking</h2>
        <p><strong>This is the #1 source of bugs for beginners!</strong></p>

        <h3>Blocking (<code>=</code>) - Executes Sequentially</h3>
<pre><code>always @(posedge clk) begin
    q1 = d;      // q1 gets NEW value immediately
    q2 = q1;     // q2 gets NEW q1 (same as d!)
end
// Result: q1 = q2 = d (NOT a shift register!)</code></pre>

        <h3>Non-Blocking (<code>&lt;=</code>) - Executes in Parallel</h3>
<pre><code>always @(posedge clk) begin
    q1 <= d;     // Both read OLD values first
    q2 <= q1;    // Then both update together
end
// Result: Proper shift register!</code></pre>

        <h3>The Rule</h3>
        <table>
            <tr><th>Logic Type</th><th>Use</th><th>Why</th></tr>
            <tr><td>Combinational</td><td><code>=</code> (blocking)</td><td>Sequential evaluation needed</td></tr>
            <tr><td>Sequential</td><td><code>&lt;=</code> (non-blocking)</td><td>Parallel FF behavior</td></tr>
        </table>

        <h2>D Flip-Flop - The Building Block</h2>
<pre><code>module dff (
    input      clk,
    input      rst_n,      // Active low async reset
    input      d,
    output reg q
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            q <= 1'b0;     // Reset value
        else
            q <= d;        // Normal operation
    end
endmodule</code></pre>

        <p><strong>Note:</strong> This is what gets converted to a scan flip-flop during DFT insertion!</p>

        <h2>Common Mistakes to Avoid</h2>

        <h3>1. Latch Inference (Missing Else)</h3>
<pre><code>// WRONG - Creates unwanted latch!
always @(*) begin
    if (sel)
        out = a;
    // Missing else! Tool infers latch to hold 'out'
end

// CORRECT - Complete assignment
always @(*) begin
    if (sel)
        out = a;
    else
        out = b;   // Or use default at beginning
end</code></pre>

        <h3>2. Incomplete Sensitivity List</h3>
<pre><code>// WRONG - Simulation/synthesis mismatch
always @(a) begin      // Missing 'b'!
    out = a & b;
end

// CORRECT - Use @(*)
always @(*) begin      // Auto-includes all
    out = a & b;
end</code></pre>

        <h3>3. Multiple Drivers</h3>
<pre><code>// WRONG - Two always blocks driving same signal
always @(posedge clk) q <= a;
always @(posedge clk) q <= b;  // Conflict!

// CORRECT - Single driver
always @(posedge clk) 
    q <= sel ? a : b;</code></pre>

        <h2>Useful Constructs</h2>

        <h3>Continuous Assignment</h3>
<pre><code>assign y = a & b;              // AND gate
assign mux_out = sel ? a : b;  // 2:1 MUX
assign {cout, sum} = a + b;    // Adder with concatenation</code></pre>

        <h3>Reduction Operators</h3>
<pre><code>assign all_ones = &data;   // AND all bits (1 if all 1s)
assign any_one  = |data;   // OR all bits (1 if any 1)
assign parity   = ^data;   // XOR all bits (odd parity)</code></pre>

        <h2>Scan Flip-Flop in Verilog</h2>
        <p>After DFT insertion, your DFF becomes:</p>

<pre><code>module scan_dff (
    input      clk,
    input      rst_n,
    input      d,           // Functional data
    input      si,          // Scan input
    input      se,          // Scan enable
    output reg q
);
    wire mux_out;
    
    // Scan MUX
    assign mux_out = se ? si : d;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            q <= 1'b0;
        else
            q <= mux_out;
    end
endmodule</code></pre>

<div class="diagram">          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    D ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ       ‚îÇ
          ‚îÇ  MUX  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫ FF ‚îÄ‚îÄ‚îÄ‚ñ∫ Q
   SI ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ       ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
             SE</div>

        <div class="summary">
            <h3>Summary</h3>
            <table>
                <tr><th>Topic</th><th>Key Point</th></tr>
                <tr><td>Always blocks</td><td><code>@(*)</code> for combo, <code>@(posedge clk)</code> for seq</td></tr>
                <tr><td>Blocking <code>=</code></td><td>Use for combinational logic</td></tr>
                <tr><td>Non-blocking <code>&lt;=</code></td><td>Use for sequential logic</td></tr>
                <tr><td>Latches</td><td>Avoid! Always have complete if-else</td></tr>
                <tr><td>Sensitivity</td><td>Use <code>@(*)</code> to avoid mistakes</td></tr>
            </table>
        </div>

        <div class="nav-buttons">
            <a href="02_Digital_Design_Fundamentals.html" class="nav-btn prev">Digital Design</a>
            <a href="04_Introduction_to_DFT.html" class="nav-btn next">Introduction to DFT</a>
        </div>
    </div>
    
    <div class="footer">
        <p>DFT Engineering Blog Series | Part 3 of 11</p>
    </div>
</body>
</html>

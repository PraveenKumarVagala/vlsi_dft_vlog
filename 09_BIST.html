<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIST - Built-In Self-Test | DFT Blog</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1><a href="index.html">ğŸ”§ DFT Blog</a></h1>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="08_At_Speed_Testing.html">â† Prev</a>
                <a href="10_JTAG.html">Next â†’</a>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="article-header">
            <span class="article-number">Part 9 of 11</span>
            <h1>BIST - Built-In Self-Test</h1>
            <p class="subtitle">The chip that tests itself</p>
            <p class="author">By <strong>Praveen Kumar Vagala</strong></p>
        </div>

        <h2>What is BIST?</h2>
        <p><strong>BIST = Built-In Self-Test</strong></p>
        <p>Test logic embedded inside the chip. No expensive external tester needed.</p>

<div class="diagram">Without BIST:                    With BIST:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Externalâ”‚â”€â”€â”€â”€â–ºâ”‚ Chip â”‚         â”‚ Chip              â”‚
â”‚Tester  â”‚â—„â”€â”€â”€â”€â”‚      â”‚         â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”˜         â”‚ â”‚ BIST Engine  â”‚  â”‚
  $$$$$$                        â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 Expensive!                     â”‚  Self-contained!  â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>

        <h2>Two Types of BIST</h2>
        <table>
            <tr><th>Type</th><th>Tests</th><th>Use Case</th></tr>
            <tr><td><strong>MBIST</strong></td><td>Embedded memories (SRAM)</td><td>Standard for all memories</td></tr>
            <tr><td><strong>LBIST</strong></td><td>Random logic</td><td>High-reliability applications</td></tr>
        </table>

        <h2>MBIST - Memory BIST</h2>

        <h3>Architecture</h3>
<div class="diagram">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MBIST Controller                                       â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚  â”‚   Address    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚  Generator   â”‚               â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚                      â”‚
â”‚                                 â–¼                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚    Data      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚          â”‚                â”‚
â”‚  â”‚  Generator   â”‚         â”‚   SRAM   â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚          â”‚â”€â”€â”€â”€â”           â”‚
â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚           â”‚
â”‚  â”‚  Expected    â”‚                         â”‚           â”‚
â”‚  â”‚    Data      â”‚â”€â”€â”€â”€â”€â”€â”€â”                 â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚                 â”‚           â”‚
â”‚                         â–¼                 â–¼           â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚                    â”‚       Comparator         â”‚       â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                â”‚                      â”‚
â”‚                           PASS/FAIL                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>

        <h3>How It Works</h3>
        <ol>
            <li><strong>Address Generator:</strong> Cycles through all memory locations</li>
            <li><strong>Data Generator:</strong> Creates test patterns (0s, 1s, checkerboard)</li>
            <li><strong>Write to SRAM:</strong> Store test data</li>
            <li><strong>Read from SRAM:</strong> Retrieve stored data</li>
            <li><strong>Compare:</strong> Match expected vs actual</li>
            <li><strong>Report:</strong> PASS if all match, FAIL otherwise</li>
        </ol>

        <h2>March Algorithm</h2>
        <p>Industry-standard memory test pattern.</p>

        <h3>March C- Algorithm</h3>
<pre><code>Step 1: â‡‘(w0)      Write 0 to all locations, ascending
Step 2: â‡‘(r0,w1)   Read 0, write 1, ascending  
Step 3: â‡‘(r1,w0)   Read 1, write 0, ascending
Step 4: â‡“(r0,w1)   Read 0, write 1, descending
Step 5: â‡“(r1,w0)   Read 1, write 0, descending
Step 6: â‡“(r0)      Read 0, descending

Notation:
  â‡‘ = Ascending address order
  â‡“ = Descending address order
  w0 = Write 0
  r1 = Read and expect 1</code></pre>

        <h3>What March Catches</h3>
        <table>
            <tr><th>Fault Type</th><th>Description</th></tr>
            <tr><td>Stuck-at</td><td>Cell always 0 or 1</td></tr>
            <tr><td>Transition</td><td>Cell can't change</td></tr>
            <tr><td>Coupling</td><td>One cell affects another</td></tr>
            <tr><td>Address decoder</td><td>Wrong cell accessed</td></tr>
            <tr><td>Read/Write logic</td><td>Data corruption</td></tr>
        </table>

        <h2>LBIST - Logic BIST</h2>
        <p>Tests random logic using pseudo-random patterns.</p>

<div class="diagram">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  LFSR  â”‚â”€â”€â”€â”€â”€â–ºâ”‚              â”‚â”€â”€â”€â”€â”€â–ºâ”‚  MISR  â”‚    â”‚
â”‚   â”‚(Patternâ”‚      â”‚   Circuit    â”‚      â”‚(Signtr)â”‚    â”‚
â”‚   â”‚ Gen)   â”‚      â”‚  Under Test  â”‚      â”‚        â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜    â”‚
â”‚                                              â”‚        â”‚
â”‚                                              â–¼        â”‚
â”‚                                    Compare with       â”‚
â”‚                                    Golden Signature   â”‚
â”‚                                              â”‚        â”‚
â”‚                                         PASS/FAIL     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>

        <h3>Components</h3>
        <ol>
            <li><strong>LFSR:</strong> Generates pseudo-random test patterns</li>
            <li><strong>Circuit Under Test:</strong> Your logic (via scan chains)</li>
            <li><strong>MISR:</strong> Compresses outputs into signature</li>
            <li><strong>Comparison:</strong> Match expected signature</li>
        </ol>

        <h2>LFSR - Pattern Generator</h2>
        <p><strong>LFSR = Linear Feedback Shift Register</strong></p>
        <p>Generates pseudo-random sequence using XOR feedback.</p>

<pre><code>module lfsr_4bit (
    input            clk, rst_n, en,
    output reg [3:0] q
);
    // Polynomial: x^4 + x^3 + 1
    // Taps at positions 4 and 3
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            q <= 4'b1111;  // Non-zero seed required!
        else if (en)
            q <= {q[2:0], q[3] ^ q[2]};  // Shift + feedback
    end
endmodule</code></pre>

        <h3>LFSR Sequence</h3>
<pre><code>4-bit LFSR cycles through 15 values (2^4 - 1):

1111 â†’ 0111 â†’ 0011 â†’ 0001 â†’ 1000 â†’ 0100 â†’ 
0010 â†’ 1001 â†’ 1100 â†’ 0110 â†’ 1011 â†’ 0101 â†’ 
1010 â†’ 1101 â†’ 1110 â†’ (back to 1111)

Never produces 0000 (would get stuck!)</code></pre>

        <h2>MISR - Signature Analyzer</h2>
        <p><strong>MISR = Multiple Input Signature Register</strong></p>
        <p>Compresses many outputs over many cycles into single signature.</p>

<pre><code>module misr_4bit (
    input            clk, rst_n, en,
    input      [3:0] data_in,
    output reg [3:0] sig
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            sig <= 4'b0;
        else if (en)
            sig <= {sig[2:0], sig[3] ^ sig[2]} ^ data_in;
    end
endmodule</code></pre>

        <h3>How Signature Works</h3>
<pre><code>Cycle 1: Output = 1010 â†’ MISR = 0x1A
Cycle 2: Output = 1100 â†’ MISR = 0x3F
Cycle 3: Output = 0110 â†’ MISR = 0x7B
...
Cycle N: Final Signature = 0xA5B7C3D1

If ANY cycle has wrong output â†’ Signature changes!
Compare with expected: Match = PASS, Mismatch = FAIL</code></pre>

        <h2>BIST vs External Test Comparison</h2>
        <table>
            <tr><th>Aspect</th><th>External Test</th><th>BIST</th></tr>
            <tr><td>Equipment</td><td>Expensive ATE</td><td>None needed</td></tr>
            <tr><td>Test time</td><td>Limited by ATE</td><td>Can run long</td></tr>
            <tr><td>Pattern storage</td><td>ATE memory</td><td>On-chip generation</td></tr>
            <tr><td>Diagnosis</td><td>Detailed fail data</td><td>Usually pass/fail only</td></tr>
            <tr><td>Field test</td><td>Not possible</td><td>Possible</td></tr>
            <tr><td>Area overhead</td><td>None</td><td>3-5%</td></tr>
        </table>

        <h2>When to Use BIST</h2>

        <h3>MBIST - Always!</h3>
        <p>Every embedded memory should have MBIST. It's:</p>
        <ul>
            <li>Standard practice</li>
            <li>Required by most customers</li>
            <li>Catches memory-specific defects</li>
        </ul>

        <h3>LBIST - Sometimes</h3>
        <p>Use for:</p>
        <ul>
            <li>Automotive (safety-critical)</li>
            <li>Medical devices</li>
            <li>High-reliability applications</li>
            <li>In-field testing</li>
        </ul>

        <div class="summary">
            <h3>Summary</h3>
            <table>
                <tr><th>Concept</th><th>Key Point</th></tr>
                <tr><td>BIST</td><td>Chip tests itself</td></tr>
                <tr><td>MBIST</td><td>Tests memories with March algorithm</td></tr>
                <tr><td>LBIST</td><td>Tests logic with LFSR/MISR</td></tr>
                <tr><td>LFSR</td><td>Generates pseudo-random patterns</td></tr>
                <tr><td>MISR</td><td>Compresses outputs to signature</td></tr>
                <tr><td>Benefit</td><td>No external tester, field testing</td></tr>
            </table>
        </div>

        <div class="nav-buttons">
            <a href="08_At_Speed_Testing.html" class="nav-btn prev">At-Speed Testing</a>
            <a href="10_JTAG.html" class="nav-btn next">JTAG</a>
        </div>
    </div>
    
    <div class="footer">
        <p>DFT Engineering Blog Series | Part 9 of 11</p>
    </div>
</body>
</html>
